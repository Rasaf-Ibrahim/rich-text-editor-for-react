/* eslint-disable react/function-component-definition */
/*__________________________________________

 ✅ import
____________________________________________*/

// react
import React from 'react'


// types
import { type_of_rte_state } from '../types/types-for-the-library';
import { RichTextEditorPropsType } from '../types/types-for-the-users'


// hook
import { useEffect, useRef } from 'react'
import { useImmer } from '../dependencies/use-immer/use-immer'
import { useLogger, useMount } from '../dependencies/react-use/react-use'


// api hook
import useCloudImage from './api-calls/cloudinary-image'


// nanoid
import { nanoid } from '../dependencies/nanoid/nanoid'


// theme component
import MUI_THEME___COMPONENT from "../theme/theme"

// mui components
import { Box } from '../dependencies/mui/components'

// child component
import QUILL_RTE___COMPONENT from './quill-rte/quill-rte'






/*__________________________________________

 ✅ Functional component 
____________________________________________*/

export default function RichTextEditor(props: RichTextEditorPropsType) {

    // 🍪 props
    const {
        customizeUI,

        toolbarOptions,

        initialValue,

        imageValidation,

        cloudImageApiEndpoint,

        fetchOutput,
        fetchUtils,
        fetchEditorStatus,

        enableImageOperations,
        fetchImageOperationsData
    } = props






    // 🍪 quill's reference 
    const quillRef = useRef(null)




    // 🍪 all the states of the rte editor in one place
    const rte_initial_state: type_of_rte_state = {

        // property to track whether quill has initialized or not
        is_quill_initialized: false,

        // property to store the HTML generated by Quill 
        quill_generated_html: '',

        // while editing, we will need to compare with the last saved html on database
        quill_generated_html_fetched_from_database: initialValue ? initialValue : '',

        // property to store the cursor position and selection range
        editor_cursor: {
            position: 0, //initial
            selection_length: 0 //initial
        },

        // property to track all kinds of editor event
        editor_change_tracker: {

            any_change: '',

            text_change: '',

            selection_change: '',

            image_inserted: '',

            image_removed: '',

            image_with_blob_src_inserted: '',

            image_with_blob_src_removed: '',

            image_with_url_src_inserted: '',

            image_with_url_src_removed: ''




            /* 🔖 As of 0.8.0, even if we are tracking all this changes, we are not using all of these yet, for example, we are not using the following changes to perform any side effect:

                text_change,
                selection_change,
                image_inserted,
                image_removed,
            */

        },

        // property to track editor status 
        editor_status: {
            has_focus: false,
            total_words: 0,
            total_characters: 0,
            total_characters_excluding_spacing: 0
        },


        // property to track all the images and their activities
        images: {

            all_inserted_blob_src_image_info: [],

            all_removed_url_src_image_id: []
        },


        // property to track formats of the selected text 
        formats_of_selected_text: {
            header: 0,
            font: 'sans-serif',
            bold: false,
            italic: false,
            underline: false,
            strike: false, // strikethrough
            list: 'none',  // ordered & unordered(bullet) list
            align: false, //text alignment
            indent: 0,
            direction: 'ltr', //rtl, ltr
            blockquote: false,
            'code-block': false,
            link: '', //inserted link
            script: 'none'


            /* 🔖
                we don't need to have the 'image' & 'video' property here because we don't track them with quillRef.current.getFormat().image or quillRef.current.getFormat().video 
            */
        }
    }


    const [rte_state, update_rte_state] = useImmer(rte_initial_state)


    // useLogger('🛑 rte_state', rte_state.editor_cursor)

    /* 🍪 (1/8) for user - indirectly updating "output" state when the user passes an initial value */
    useMount(() => {

        if (initialValue) {

            /*🔖 
                "quillRef.current.root.innerHTML" is the root. 
                
                When "quillRef.current.root.innerHTML" gets updated, "rte_state.quill_generated_html" gets updated as well.
                
                And when "rte_state.quill_generated_html" gets updated, "output" state also gets updated. (check '2/8' to see this in effect) 
            
            */
            quillRef.current.root.innerHTML = initialValue
        }

    })



    /* 🍪 (2/8) for user -  updating "output" state */
    useEffect(() => {

        fetchOutput(rte_state.quill_generated_html)

    }, [rte_state])




    /* 🍪 (3/8) for user -  updating the "utils" state  */

    useEffect(() => {

        if (fetchUtils) {

            fetchUtils(prevState => ({

                ...prevState, // Copy the previous state

                resetEditor: () => {
                    quillRef.current.setText('')
                },

                /* even if we use '' for resetting, quill will reset by generating '<p><br></p>' */


                focusOnEditor: () => {
                    quillRef.current.focus()
                },

                removeFocusFromEditor: () => {
                    quillRef.current.blur()
                },


            }))

        }

    }, [quillRef.current])




    /* 🍪 (4/8) for user -  updating the "editorStatus" state  */
    useEffect(() => {

        if (!fetchEditorStatus) return

        fetchEditorStatus(prevState => ({

            ...prevState, // Copy the previous state

            hasFocus: rte_state.editor_status.has_focus,

            totalWords: rte_state.editor_status.total_words,

            totalCharacters: rte_state.editor_status.total_characters,

            totalCharactersExcludingSpacing: rte_state.editor_status.total_characters_excluding_spacing
        }))

    }, [rte_state.editor_status])






    /* 🍪 (5/8) for user - preparing the image upload and delete function */

    const { mutate, isLoading, isSuccess, isError, data } = useCloudImage()


    const upload_and_delete_image = () => {

        const formData: any = new FormData()

        for (let image_info of rte_state.images.all_inserted_blob_src_image_info) {
            formData.append('imagesToUpload', image_info.img_file, image_info.img_id)
        }

        for (let removed_url_image_id of rte_state.images.all_removed_url_src_image_id) {

            formData.append('imagesToDelete', removed_url_image_id)
        }


        mutate(cloudImageApiEndpoint, formData)
    }



    /* 🍪 (6/8) for user -
        
         when the "enableImageOperations" state changes,
    
        - executing image upload and delete function for the user 

        - also updating some specific properties of the "imageOperationsData" state to let the user know about the update status
        
    */


    useEffect(() => {


        if (enableImageOperations === '') return



        // first, update the "imageOperationsData" to let the user know how many images are being uploaded
        fetchImageOperationsData(prevState => ({

            ...prevState, // Copy the previous state

            totalUploading: rte_state.images.all_inserted_blob_src_image_info.length,

            totalDeleting: rte_state.images.all_removed_url_src_image_id.length
        }))



        // if there is no image to upload or delete, update the "imageOperationsData" to let the user know that they can safely  submit the data
        if (rte_state.images.all_inserted_blob_src_image_info.length === 0 && rte_state.images.all_removed_url_src_image_id.length === 0) {

    
            fetchImageOperationsData(prevState => ({

                ...prevState, // Copy the previous state

                outputUpdatedWithImageLink: nanoid(8)
            }))

        }


        // if there is image to upload or delete, run the "upload_and_delete_image" function
        else {
            upload_and_delete_image()
        }


    }, [enableImageOperations])




    /* 🍪 (7/8) for user -  updating the "imageOperationsData" state based on the response of the image upload and delete functionality  */
    useEffect(() => {

        // if user doesn't want operations data, return
        if (!fetchImageOperationsData) return


        fetchImageOperationsData(prevState => ({

            ...prevState, // Copy the previous state

            isProcessing: isLoading,
            hasSucceed: isSuccess,
            hasFailed: isError
        }))

    }, [isLoading, isSuccess, isError])









    /* 🍪 (8/8) for user - 
    
        - from the above step, if we get a successful response back, we will update the 'quillRef.current.root.innerHTML'


        - after that, updating a specific property of the "imageOperationsData" state to let the user know blob image has been updated with the actual link and they can safely save the output of the rich text editor in database.   
        
    */


    useEffect(() => {

        if (!isSuccess) return


        // 🥔 function to update the image src and id
        function updateImageSrcAndId(html: string, imageInfoArray: Array<{ publicID: string, src: string }>): string {

            // Use DOMParser to create a new Document from the HTML string
            const parser = new DOMParser()
            const doc = parser.parseFromString(html, 'text/html')

            // Query all img tags in the document
            const imgTags = doc.getElementsByTagName('img');

            // Convert HTMLCollection to array and loop through each img tag using for...of loop
            for (const img of Array.from(imgTags)) {

                // Get the current image's data-id
                const currentImageId = img.getAttribute('data-image-id')

                // Find the matching item in the image response array
                const matchingItem = imageInfoArray.find(item => item.publicID.split('/')[1] === currentImageId)

                // If a matching item was found, update the img tag's src and data-id attributes
                if (matchingItem) {
                    img.setAttribute('src', matchingItem.src);
                    img.setAttribute('data-image-id', matchingItem.publicID)
                }
            }

            // Return the updated HTML string
            return doc.documentElement.innerHTML
        }


        // 🥔 function to extract images' id
        function extractImageIds(html: string): string[] {

            // Use DOMParser to create a new Document from the HTML string
            const parser = new DOMParser();
            const doc = parser.parseFromString(html, 'text/html');

            // Query all img tags in the document
            const imgTags = doc.getElementsByTagName('img');

            // Initialize an array to hold the data-image-id values
            const dataImageIds: string[] = [];

            // Convert HTMLCollection to array and loop through each img tag using for...of loop
            for (const img of Array.from(imgTags)) {

                // Get the current image's src attribute
                const srcAttribute = img.getAttribute('src');

                // Get the current image's data-image-id attribute
                const dataImageId = img.getAttribute('data-image-id');

                // If src attribute starts with http or https and data-image-id is not null, add it to the array
                if (srcAttribute && (srcAttribute.startsWith('http') || srcAttribute.startsWith('https')) && dataImageId) {
                    dataImageIds.push(dataImageId);
                }
            }

            // Return the array of data-image-id values
            return dataImageIds;
        }


        // 🥔 if user doesn't want operations data, return
        if (!fetchImageOperationsData) return

        //  🥔 before we update the image src and data id of the editor's html, we are updating the "updatingTheOutputWithImageLink" state
        fetchImageOperationsData(prevState => ({

            ...prevState, // Copy the previous state

            updatingTheOutputWithImageLink: true
        }))



        // 🥔 updating image src and data id of the editor's html
        if (data?.result && Array.isArray(data.result)) {

            // we are making sure that 'result' is passed and it's an array, before trying to update the innerHTML

            quillRef.current.root.innerHTML = updateImageSrcAndId(rte_state.quill_generated_html, data.result)
        }




        /* 🥔 after we update the "quillRef.current.root.innerHTML", we need to update the "imageOperationsData.outputUpdatedWithImageLink" & "imageOperationsData.idsOfTheImages" state.

            But before updating these states, we will wait 2 seconds.  Because:

            when we update the "quillRef.current.root.innerHTML", the editor's html gets updated, editor-change event occurs, the "rte_state.quill_generated_html" state gets updated, and so the user's "output" state also gets updated 

            basically, we need to wait till the "output" gets updated and it wouldn't take more than 2 seconds, so we are waiting 2 seconds

        */
        setTimeout(() => {

            fetchImageOperationsData(prevState => ({

                ...prevState, // Copy the previous state

                idsOfTheImages: extractImageIds(quillRef.current.root.innerHTML),

                updatingTheOutputWithImageLink: false,

                outputUpdatedWithImageLink: nanoid(8)

            }))

        }, 2000)



    }, [isSuccess])





    /*✅  TSX  ✅*/

    return (

        <>

            <MUI_THEME___COMPONENT
                backgroundColor={customizeUI.backgroundColor}
                primaryColor={customizeUI.primaryColor}
                iconColor={customizeUI.iconColor}
                typography={customizeUI.typography}
            >

                <Box sx={(theme) => ({
                    display: 'flex',
                    flexDirection: 'column',
                    alignItems: 'stretch',
                    gap: '1rem'
                })}>



                    <QUILL_RTE___COMPONENT
                        quillRef={quillRef}
                        rte_initial_state={rte_initial_state}
                        rte_state={rte_state}
                        update_rte_state={update_rte_state}
                        display_these_toolbar_options={toolbarOptions}
                        customizeUI={customizeUI}
                        imageValidation={imageValidation}
                    />

                </Box>

            </MUI_THEME___COMPONENT>

        </>

    )


}
















