/* eslint-disable react/function-component-definition */
/*__________________________________________

 âœ… import
____________________________________________*/

// react
import React from 'react'

// hook
import { useEffect, useRef } from 'react'
import { useImmer } from 'use-immer';
import { useLogger, useMount, useUpdateEffect } from 'react-use'

// api hook
import useCloudImage from './api-calls/cloudinary-image'

// nanoid
import { nanoid } from 'nanoid';


// types
import { type_of_rte_state } from '../types/types-for-the-library';
import { RichTextEditorPropsType } from '../types/types-for-the-users'


//theme
import MUI_THEME___COMPONENT from "../theme/theme"

// mui components
import { Box } from './quill-rte/toolbar/mui/components'

// child component
import QUILL_RTE___COMPONENT from './quill-rte/quill-rte'






/*__________________________________________

 âœ… Functional component 
____________________________________________*/

export default function RichTextEditor(props:RichTextEditorPropsType) {

    // ðŸ«“ props
    const {
        customizeUI,

        toolbarOptions,

        initialValue,

        imageValidation,

        cloudImageApiEndpoint,

        fetchOutput,
        fetchUtils,
        fetchEditorStatus,

        isImageOperationsEnabled,
        fetchImageOperationsData
    } = props










    // ðŸ«“ quill's reference 
    const quillRef = useRef(null)




    // ðŸ«“ all the states of the rte editor in one place
    const rte_initial_state: type_of_rte_state = {

        // property to store the HTML generated by Quill 
        quill_generated_html: '',

        // while editing, we will need to compare with the last saved html on database
        quill_generated_html_fetched_from_database: initialValue ? initialValue : '',

        // property to store the cursor position and selection range
        editor_cursor: {
            position: 0, //initial
            selection_length: 0 //initial
        },

        // property to track all kinds of editor event
        editor_events_state: {

            any_change: '',

            text_change: '',

            selection_change: '',

            image_inserted: '',

            image_removed: '',

            image_with_blob_src_inserted: '',

            image_with_blob_src_removed: '',

            image_with_url_src_inserted: '',

            image_with_url_src_removed: ''

        },

        // property to track editor status 
        editor_status: {
            has_focus: false,
            total_words: 0,
            total_characters: 0,
            total_characters_excluding_spacing: 0
        },


        // property to track all the images and their activities
        images: {

            all_inserted_blob_src_image_info: [],

            all_removed_url_src_image_id: [],

            trigger_replacement_of_blob_with_url: ''
        },


        // property to track formats of the selected text 
        formats_of_selected_text: {
            header: 0,
            font: 'sans-serif',
            bold: false,
            italic: false,
            underline: false,
            strike: false, // strikethrough
            list: 'none',  // ordered & unordered(bullet) list
            align: false, //text alignment
            indent: 0,
            direction: 'ltr', //rtl, ltr
            blockquote: false,
            'code-block': false,
            link: '', //inserted link
            script: 'none'


            /* ðŸ”–
                we don't need to have the 'image' & 'video' property here because we don't track them with quillRef.current.getFormat().image or quillRef.current.getFormat().video 
            */
        }
    }


    const [rte_state, update_rte_state] = useImmer(rte_initial_state)


    // useLogger('ðŸ›‘ rte_state', rte_state)


    /* ðŸ«“ (1/8) for user - indirectly updating "output" state when the user passes an initial value */
    useMount(() => {

        if (initialValue) {

            /*ðŸ”– 
                "quillRef.current.root.innerHTML" is the root. 
                
                When "quillRef.current.root.innerHTML" gets updated, "rte_state.quill_generated_html" gets updated as well.
                
                And when "rte_state.quill_generated_html" gets updated, "output" state also gets updated. (check '2/8' to see this in effect) 
            
            */
            quillRef.current.root.innerHTML = initialValue
        }

    })



    /* ðŸ«“ (2/8) for user -  updating "output" state */
    useEffect(() => {

        fetchOutput(rte_state.quill_generated_html)

    }, [rte_state])




    /* ðŸ«“ (3/8) for user -  updating the "utils" state  */

    useEffect(() => {

        if (fetchUtils) {

            fetchUtils(prevState => ({

                ...prevState, // Copy the previous state

                resetEditor: () => {
                    quillRef.current.setText('')
                },

                /* even if we use '' for resetting, quill will reset by generating '<p><br></p>' */


                focusOnEditor: () => {
                    quillRef.current.focus()
                },

                removeFocusFromEditor: () => {
                    quillRef.current.blur()
                },


            }))

        }

    }, [quillRef.current])




    /* ðŸ«“ (4/8) for user -  updating the "editorStatus" state  */
    useUpdateEffect(() => {

        if (fetchEditorStatus) {

            fetchEditorStatus(prevState => ({

                ...prevState, // Copy the previous state

                hasFocus: rte_state.editor_status.has_focus,

                totalWords: rte_state.editor_status.total_words,

                totalCharacters: rte_state.editor_status.total_characters,

                totalCharactersExcludingSpacing: rte_state.editor_status.total_characters_excluding_spacing
            }))

        }

    }, [rte_state.editor_status])






    /* ðŸ«“ (5/8) for user - preparing the image upload and delete function */

    const { mutate, isLoading, isSuccess, isError, data } = useCloudImage()


    const upload_and_delete_image = () => {

        const formData: any = new FormData()

        for (let image_info of rte_state.images.all_inserted_blob_src_image_info) {
            formData.append('imagesToUpload', image_info.img_file, image_info.img_id)
        }

        for (let removed_url_image_id of rte_state.images.all_removed_url_src_image_id) {

            formData.append('imagesToDelete', removed_url_image_id)
        }


        mutate(cloudImageApiEndpoint, formData)
    }



    /* ðŸ«“ (6/8) for user -
        
         when the "isImageOperationsEnabled" state changes,
    
        - executing image upload and delete function for the user 

        - also updating some specific properties of the "imageOperationsData" state to let the user know about the update status
        
    */

    useUpdateEffect(() => {

        // first, update the "imageOperationsData" to let the user know how many images are being uploaded
        fetchImageOperationsData(prevState => ({

            ...prevState, // Copy the previous state

            totalUploading: rte_state.images.all_inserted_blob_src_image_info.length,

            totalDeleting: rte_state.images.all_removed_url_src_image_id.length

        }))



        // if there is no image to upload, update the "imageOperationsData" to let the user know that they can safely  submit the data
        if (rte_state.images.all_inserted_blob_src_image_info.length === 0) {

            fetchImageOperationsData(prevState => ({

                ...prevState, // Copy the previous state

                outputUpdatedWithImageLink: nanoid(8)
            }))

        }


        // if there is image to upload, upload them
        else {
            upload_and_delete_image()
        }


    }, [isImageOperationsEnabled])




    /* ðŸ«“ (7/8) for user -  updating the "imageOperationsData" state based on the response of the image upload and delete functionality  */


    useEffect(() => {

        // if user doesn't want operations data, return
        if(!fetchImageOperationsData) return;


        fetchImageOperationsData(prevState => ({

            ...prevState, // Copy the previous state

            isProcessing: isLoading,
            hasSucceed: isSuccess,
            hasFailed: isError
        }))

    }, [isLoading, isSuccess, isError])





    /* ðŸ«“ (8/8) for user - 
    
        - from the above step, if we get a successful response back, we will update the 'quillRef.current.root.innerHTML'


        - after that, updating a specific property of the "imageOperationsData" state to let the user know blob image has been updated with the actual link and they can safely save the output of the rich text editor in database.   
        

    */

    useUpdateEffect(() => {


        // ðŸ¥” update_image_src_and_data_id function
        function update_image_src_and_data_id(html, responseArray) {

            // Use DOMParser to create a new Document from the HTML string
            const parser = new DOMParser();
            const doc = parser.parseFromString(html, 'text/html');

            // Query all img tags in the document
            const imgTags = doc.getElementsByTagName('img');

            // Loop through each img tag
            for (let i = 0; i < imgTags.length; i++) {
                const img = imgTags[i];

                // Get the current image's data-id
                const currentImageId = img.getAttribute('data-image-id');

                // Find the matching item in the response array
                const matchingItem = responseArray.find(item => item.public_id.split('/')[1] === currentImageId);

                // If a matching item was found, update the img tag's src and data-id attributes
                if (matchingItem) {
                    img.setAttribute('src', matchingItem.src);
                    img.setAttribute('data-image-id', matchingItem.public_id);
                }
            }


            // Return the updated HTML string
            return doc.documentElement.innerHTML
        }


        // ðŸ¥” updating image src and data id of the editor's html
        quillRef.current.root.innerHTML = update_image_src_and_data_id(rte_state.quill_generated_html, data?.result)



        /* ðŸ¥” after we update the "quillRef.current.root.innerHTML", we need to update the "imageOperationsData.outputUpdatedWithImageLink" state.

            But before updating this state, we will wait 2 seconds.  Because:

            when we update the "quillRef.current.root.innerHTML", the editor's html gets updated, editor-change event occurs, the "rte_state.quill_generated_html" state gets updated, and so the user's "output" state also gets updated 

            basically, we need to wait till the "output" gets updated and it wouldn't take more than 2 seconds, so we are waiting 2 seconds

        */
        setTimeout(() => {

            fetchImageOperationsData(prevState => ({

                ...prevState, // Copy the previous state

                outputUpdatedWithImageLink: nanoid(8)
            }))

        }, 2000);



    }, [isSuccess])





    /*âœ…  TSX  âœ…*/

    return (

        <>

            <MUI_THEME___COMPONENT
                backgroundColor={customizeUI.backgroundColor}
                primaryColor={customizeUI.primaryColor}
                iconColor={customizeUI.iconColor}
                typography={customizeUI.typography}
            >

                <Box sx={(theme) => ({
                    display: 'flex',
                    flexDirection: 'column',
                    alignItems: 'stretch',
                    gap: '1rem'
                })}>



                    <QUILL_RTE___COMPONENT
                        quillRef={quillRef}
                        rte_initial_state={rte_initial_state}
                        rte_state={rte_state}
                        update_rte_state={update_rte_state}
                        display_these_toolbar_options={toolbarOptions}
                        customizeUI={customizeUI}
                        imageValidation={imageValidation}
                    />

                </Box>

            </MUI_THEME___COMPONENT>

        </>

    )


}
















